{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"정리노트","configs":{"countOfInitialPost":10}}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"웹 워커(Web worker)란? 웹 워커(Web worker)는 스크립트 연산을 웹 어플리케이션의 주 실행 스레드와 분리된 별도의 백그라운드 스레드에서 실행할 수 있는 기술입니다. 웹 워커를 통해 무거운 작업을 분리된 스레드에서 처리하면 주 스레드가 멈추거나 느려지지 않고 동작할 수 있습니다. 웹 워커를 사용하는 이유 싱글 스레드 방식으로만 작동 할 수…","fields":{"slug":"/javascript/웹-워커(web-worker)란?/"},"frontmatter":{"date":"September 15, 2020","title":"웹 워커(Web worker)로 DOM 업데이트 개선","category":"javascript"}}},{"node":{"excerpt":"컴포먼트의 로직을 재사용하기 위해서 고차 컴포넌트(Higher-Order Components)를 사용해왔습니다. 하지만  custom hook으로 더 간편하게 상태관리 로직을 공유할 수 있습니다. 예1) React 공식문서 예제 위 코드는 외부로부터 데이터를 구독하여 댓글목록을 렌더링하는 CommentList 컴포먼트 입니다. 그리고 밑에는 블로그 포스트…","fields":{"slug":"/react/react---customhook/"},"frontmatter":{"date":"December 23, 2019","title":"react - custom hook 사용하기","category":"react"}}},{"node":{"excerpt":"Javascript 동기/비동기 자바스크립트는 하나의 callStack으로 요청을 순차적으로 진행합니다. 하지만 아래와 같은 상황이 있습니다. setTimeout은 Web API의 한 종류로 코드를 일정시간 만큼 기다렸다가 로직을 실행시킵니다. 만약 순차적으로만 진행이 된다면 a -> b -> c 순으로 실행되야만 합니다. 하지만 결과는 a -> c ->…","fields":{"slug":"/javascript/javascript---promise/"},"frontmatter":{"date":"December 22, 2019","title":"javascript - 동기/비동기","category":"javascript"}}},{"node":{"excerpt":"Exhaustive-deps warning React Hook useEffect has a missing dependency: ‘xxx’. Either include it or remove the dependency array react로 개발을 하다보면 한번쯤은 봤을법한 warning이다. useEffect에 누락된 종속성이 있어 배열안에 종속성을 추가…","fields":{"slug":"/react/react--exhaustive-deps/"},"frontmatter":{"date":"December 19, 2019","title":"React - exhaustive-deps warning 해결법","category":"react"}}},{"node":{"excerpt":"React의 Hook 중에 useCallback과 useMemo를 활용하여 최적화 하는 방법을 알아보았다. React가 렌더링을 실행하는 행동 Props가 변경되었을 때 State가 변경되었을 때 부모 컴포넌트가 렌더링 되었을 때 focueUpdate() 를 실행하였을 때 주목해야 될 점은 부모 컴포넌트가 렌더링 되었을때 자식 컴포넌트까지 다시 렌더링이 …","fields":{"slug":"/react/react---usecallback,-useMemo/"},"frontmatter":{"date":"December 16, 2019","title":"react - useCallback, memo re-render 최적화","category":"react"}}},{"node":{"excerpt":"switch useReducer 예제를 보던 도중 switch case절 후에 문장 주위에 중괄호를 넣는 것을 알게되었습니다. 그다지 다르지 않고 넘어 지지 않도록 진술의 끝 break이나 return끝에서 여전히 필요 하지만 중괄호만에 좋은 장점이 있습니다. 장점 중괄호는 블록 scope를 만들게 됩니다. 그 뜻은 각 case 마다 다른 블록 scope…","fields":{"slug":"/javascript/자바스크립트-switch-구문/"},"frontmatter":{"date":"December 13, 2019","title":"자바스크립트 switch 구문","category":"javascript"}}},{"node":{"excerpt":"Vector 백터는 크기와 방향을 동시해 나타낸다. 예를들어 자동차가 시속 5mps로 움직인다 하면 이 정보는 벡터가 아니다 왜냐하면 자동차가 어떠한 방향으로 움직였는지 알 수 없기 때문이다 때문에 이 정보는 스칼라가 된다. 이 값이 벡터가 되기 위해선 방향을 알아야된다 예를들어 자동차가 시속 5mps로 동쪽으로 움직인다. 이 정보는 벡터가 된다. 그래프…","fields":{"slug":"/Math/선형대수학---벡터의-기본/"},"frontmatter":{"date":"December 09, 2019","title":"선형대수학 - 벡터의 기본","category":"Math"}}},{"node":{"excerpt":"javascript V8 엔진이란 V8 엔진은 구글이 만들었으며, C++로 제작됩니다. 구글 크롬과 nodejs 런타임에서도 사용되고 있습니다. V8 엔진 탄생배경 웹 브라우저 내부에서 자바스크립트의 수행속도 개선을 목표로 고안되었습니다. 속도향상을 위해 인터프린터를 사용하는 대신 자바스크립트를 더 효율적인 머신코드로 번역합니다. 저스트인타임 컴파일러를 …","fields":{"slug":"/javascript/자바스크립트-v8-engine-작동원리/"},"frontmatter":{"date":"December 02, 2019","title":"자바스크립트 V8 Engine 작동원리","category":"javascript"}}},{"node":{"excerpt":"React Context React로 하위컴포먼트에게 props를 넘길때 사용하지 않는 여러 컴포먼트를 거쳐 넘겨줘야 하는것은 번거롭다 Context로 간편하게 처리하자 Context 사용전 React 공식문서에 있는 예제, user와 avatarSize props를 여러단계의 거처서 보낸다. 하지만 정작 사용하는곳은 마지막 Link부분이다. 다른 값을 …","fields":{"slug":"/react/react---context/"},"frontmatter":{"date":"November 28, 2019","title":"React - Context","category":"react"}}},{"node":{"excerpt":"React Portals 툴팁을 렌더링하던 도중 상위 컴포먼트의 style때문에 위치잡는데 어려움이 생겼다 Portal로 해결됬다 보통 컴포먼트 렌더링 컴포먼트 메서드에서 엘리먼트를 반환할때 그 엘리먼트는 부모노드의 가장 가까운 저식으로 마운트된다. 그렇기 때문에 상위컴포먼트의 영향을 받아 문제가 생길 수도 있다. Portals Portals을 사용하면 …","fields":{"slug":"/react/react---portals/"},"frontmatter":{"date":"November 26, 2019","title":"React - Portals","category":"react"}}},{"node":{"excerpt":"Typescript keyof 기본 색인타입으로 동적으로 object의 properties를 확인하는데 사용할 수 있다 object의 properties를 선택하는 경우 propertyNames에 key를 배열의 형태로 넘기면 object의 해당 key만 반환하는 코드이다. 만약 propertyNames가 object에 존재해야만 한다면 keyof를 사용…","fields":{"slug":"/typescript/typescript---keyof/"},"frontmatter":{"date":"November 19, 2019","title":"typescript - keyof 기본","category":"typescript"}}},{"node":{"excerpt":"Typescript Generics(제네릭) 단일 유형이 아닌 다양한 유형에서 작동될수 있는 컴포먼트 작성이 가능하다. 전달된 argament와 동일한 유형을 return 하는 경우 만약 문자를 입력하는 경우에는 문자용으로 새 함수를 생성해야된다. any 유형을 사용할 경우 any 유형을 사용하여 만들어도 되지만 반환될때 해당 유형의 정보가 손실되어도 정…","fields":{"slug":"/typescript/typescript---generics/"},"frontmatter":{"date":"November 15, 2019","title":"TypeScript - Generics","category":"typescript"}}}]}},"pageContext":{}},"staticQueryHashes":["3128451518","96099027"]}